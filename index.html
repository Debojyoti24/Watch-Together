<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YouTube Watch Together</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #1a1a2e;
        color: #e0e0e0;
      }
      .container {
        max-width: 90%;
        margin: auto;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }
      @media (min-width: 1024px) {
        .container {
          flex-direction: row;
          justify-content: center;
          gap: 4rem;
        }
      }
      .card {
        background-color: #2a2a44;
        padding: 2rem;
        border-radius: 1.5rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }
      .btn {
        padding: 0.75rem 1.5rem;
        border-radius: 9999px;
        font-weight: 600;
        transition: all 0.3s ease;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }
      .btn-primary {
        background-color: #6a1b9a;
        color: #ffffff;
      }
      .btn-primary:hover {
        background-color: #7b1fa2;
      }
      .btn-danger {
        background-color: #b71c1c;
        color: #ffffff;
      }
      .btn-danger:hover {
        background-color: #c62828;
      }
      .input {
        background-color: #1a1a2e;
        color: #e0e0e0;
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        border: 1px solid #3f3f5a;
      }
      .chat-box {
        background-color: #1a1a2e;
        border-radius: 0.75rem;
        padding: 1rem;
        border: 1px solid #3f3f5a;
        min-height: 200px;
        max-height: 300px;
        overflow-y: auto;
      }
      .chat-message {
        margin-bottom: 0.5rem;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
      }
      .my-message {
        background-color: #6a1b9a;
        align-self: flex-end;
        margin-left: auto;
      }
      .peer-message {
        background-color: #3f3f5a;
        align-self: flex-start;
      }
      .status-message {
        text-align: center;
        font-style: italic;
        color: #8b5cf6;
        margin: 0.5rem 0;
      }
    </style>
  </head>
  <body
    class="bg-gray-900 text-gray-100 min-h-screen flex items-center justify-center py-10"
  >
    <div class="container lg:flex-row flex-col p-8">
      <div class="card w-full lg:w-1/2 flex flex-col items-center gap-6">
        <h1 class="text-3xl font-bold text-white mb-4">
          YouTube Watch Together
        </h1>
        <p id="status-display" class="text-yellow-400 font-semibold text-sm">
          Status: Not connected
        </p>
        <div id="player" class="w-full"></div>

        <div class="flex flex-col w-full gap-4">
          <input
            type="text"
            id="youtube-url-input"
            placeholder="Paste YouTube video URL here"
            class="input w-full"
          />
          <input
            type="text"
            id="ws-server-input"
            value="ws://localhost:8080"
            placeholder="Signaling Server URL"
            class="input w-full"
          />
          <input
            type="text"
            id="room-id-input"
            placeholder="Enter room ID (e.g., my-movie-date)"
            class="input w-full"
          />
          <button id="load-video-btn" class="btn btn-primary w-full">
            Load Video
          </button>
        </div>

        <div class="flex justify-between w-full mt-4">
          <button id="connect-btn" class="btn btn-primary">Connect</button>
          <button
            id="disconnect-btn"
            class="btn btn-danger"
            style="display: none"
          >
            Disconnect
          </button>
        </div>
      </div>

      <div
        class="card w-full lg:w-1/2 flex flex-col items-center gap-6 mt-8 lg:mt-0"
      >
        <h2 class="text-2xl font-bold text-white">Group Chat</h2>
        <div id="chat-messages" class="chat-box w-full flex flex-col-reverse">
          <p class="status-message">Chat will appear here...</p>
        </div>
        <div class="flex w-full gap-2">
          <input
            type="text"
            id="chat-input"
            placeholder="Type a message..."
            class="input flex-grow"
          />
          <button id="send-btn" class="btn btn-primary">Send</button>
        </div>
      </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
      // Set up global variables for the YouTube player and WebRTC connection.
      let player;
      let ws;
      let rtcPeerConnection;
      let dataChannel;
      let isNegotiating = false; // Flag to prevent multiple negotiations
      let isPlayingExternally = false; // Prevents local play/pause from being sent again

      // Get DOM elements.
      const youtubeUrlInput = document.getElementById("youtube-url-input");
      const wsServerInput = document.getElementById("ws-server-input");
      const roomIdInput = document.getElementById("room-id-input");
      const loadVideoBtn = document.getElementById("load-video-btn");
      const connectBtn = document.getElementById("connect-btn");
      const disconnectBtn = document.getElementById("disconnect-btn");
      const chatInput = document.getElementById("chat-input");
      const sendBtn = document.getElementById("send-btn");
      const chatMessages = document.getElementById("chat-messages");
      const statusDisplay = document.getElementById("status-display");

      // Function to update the status display on the UI.
      const updateStatus = (message) => {
        statusDisplay.textContent = `Status: ${message}`;
      };

      // Function to display a chat message.
      const addChatMessage = (message, isLocal = false) => {
        const messageElement = document.createElement("p");
        messageElement.classList.add(
          "chat-message",
          isLocal ? "my-message" : "peer-message"
        );
        messageElement.textContent = message;
        chatMessages.prepend(messageElement);
      };

      // This function will be called automatically when the YouTube IFrame API is ready.
      function onYouTubeIframeAPIReady() {
        player = new YT.Player("player", {
          height: "390",
          width: "640",
          videoId: "",
          playerVars: {
            playsinline: 1,
          },
          events: {
            onReady: onPlayerReady,
            onStateChange: onPlayerStateChange,
          },
        });
      }

      // Event listener for the "Load Video" button.
      loadVideoBtn.addEventListener("click", () => {
        const url = youtubeUrlInput.value;
        const videoId = getYouTubeVideoId(url);
        if (videoId) {
          player.loadVideoById(videoId);
        } else {
          updateStatus("Invalid YouTube URL");
        }
      });

      // Event listener for the "Connect" button.
      connectBtn.addEventListener("click", () => {
        const roomId = roomIdInput.value;
        if (!roomId) {
          updateStatus("Please enter a room ID.");
          return;
        }
        connectToSignalingServer(roomId);
      });

      // Event listener for the "Disconnect" button.
      disconnectBtn.addEventListener("click", () => {
        if (ws) {
          ws.close();
        }
        if (rtcPeerConnection) {
          rtcPeerConnection.close();
        }
        updateStatus("Disconnected.");
        connectBtn.style.display = "inline-block";
        disconnectBtn.style.display = "none";
      });

      // Event listener for sending chat messages.
      sendBtn.addEventListener("click", () => {
        const message = chatInput.value;
        if (message && dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(message);
          addChatMessage(`You: ${message}`, true);
          chatInput.value = "";
        } else {
          updateStatus("Cannot send message. Not connected to a peer.");
        }
      });

      // Handles the player ready event.
      function onPlayerReady(event) {
        updateStatus("Player is ready.");
      }

      // Handles player state changes and sends updates to the peer.
      function onPlayerStateChange(event) {
        if (isPlayingExternally) {
          isPlayingExternally = false;
          return;
        }
        if (dataChannel && dataChannel.readyState === "open") {
          const message = {
            type: "youtube-state",
            payload: {
              state: event.data,
              currentTime: player.getCurrentTime(),
            },
          };
          dataChannel.send(JSON.stringify(message));
        }
      }

      // Extracts the YouTube video ID from a URL.
      function getYouTubeVideoId(url) {
        const regex =
          /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/ ]{11})/i;
        const match = url.match(regex);
        return match ? match[1] : null;
      }

      // Sets up the WebSocket connection to the signaling server.
      function connectToSignalingServer(roomId) {
        const wsServerUrl = wsServerInput.value;
        updateStatus(`Connecting to signaling server at: ${wsServerUrl}...`);
        ws = new WebSocket(wsServerUrl);

        ws.onopen = () => {
          ws.send(JSON.stringify({ type: "join", room: roomId }));
          updateStatus(`Joining room ${roomId}...`);
        };

        ws.onmessage = async (event) => {
          const data = JSON.parse(event.data);
          const { type, payload } = data;

          switch (type) {
            case "ready":
              updateStatus("Peer is ready. Starting WebRTC connection...");
              await startWebRTCConnection(true);
              break;
            case "offer":
              await startWebRTCConnection(false, payload);
              break;
            case "answer":
              if (
                rtcPeerConnection &&
                rtcPeerConnection.signalingState === "have-local-offer"
              ) {
                await rtcPeerConnection.setRemoteDescription(payload);
              }
              break;
            case "ice-candidate":
              if (rtcPeerConnection) {
                try {
                  await rtcPeerConnection.addIceCandidate(payload);
                } catch (e) {
                  console.error("Error adding received ICE candidate", e);
                }
              }
              break;
            default:
              console.log("Received unknown message type:", type);
          }
        };

        ws.onclose = () => {
          updateStatus("Disconnected from signaling server.");
        };

        ws.onerror = (error) => {
          console.error("WebSocket Error:", error);
          updateStatus(
            "Failed to connect to signaling server. Please ensure the server is running and the URL is correct."
          );
        };
      }

      // The core WebRTC connection logic.
      async function startWebRTCConnection(isInitiator, remoteOffer = null) {
        // Set up STUN servers to find the public IP. Google's STUN servers are used here.
        const configuration = {
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        };

        // Create a new peer connection.
        rtcPeerConnection = new RTCPeerConnection(configuration);

        // Set up the data channel for communication.
        dataChannel = rtcPeerConnection.createDataChannel("sync");

        // Handle datachannel events.
        dataChannel.onopen = () => {
          updateStatus("Connected! Peer is ready.");
          connectBtn.style.display = "none";
          disconnectBtn.style.display = "inline-block";
        };
        dataChannel.onclose = () => {
          updateStatus("Data channel closed.");
        };
        dataChannel.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            if (message.type === "youtube-state") {
              // Logic to handle YouTube video state synchronization.
              const { state, currentTime } = message.payload;
              isPlayingExternally = true;
              if (state === YT.PlayerState.PLAYING) {
                player.seekTo(currentTime, true);
                player.playVideo();
              } else if (state === YT.PlayerState.PAUSED) {
                player.pauseVideo();
              }
            } else {
              // It's a regular chat message.
              addChatMessage(`Peer: ${event.data}`);
            }
          } catch (e) {
            addChatMessage(`Peer: ${event.data}`);
          }
        };

        // This is the heart of the "perfect negotiation" pattern.
        // It automatically handles the offer/answer exchange.
        rtcPeerConnection.addEventListener("negotiationneeded", async () => {
          if (isInitiator && !isNegotiating) {
            isNegotiating = true;
            try {
              await rtcPeerConnection.setLocalDescription();
              ws.send(
                JSON.stringify({
                  type: "offer",
                  room: roomIdInput.value,
                  payload: rtcPeerConnection.localDescription,
                })
              );
            } catch (err) {
              console.error("Error creating offer:", err);
            } finally {
              isNegotiating = false;
            }
          }
        });

        // Handle ICE candidates and send them to the peer via the signaling server.
        rtcPeerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            ws.send(
              JSON.stringify({
                type: "ice-candidate",
                room: roomIdInput.value,
                payload: event.candidate,
              })
            );
          }
        };

        // Set up remote description and create an answer if we are the receiver.
        if (!isInitiator && remoteOffer) {
          await rtcPeerConnection.setRemoteDescription(remoteOffer);
          const answer = await rtcPeerConnection.createAnswer();
          await rtcPeerConnection.setLocalDescription(answer);
          ws.send(
            JSON.stringify({
              type: "answer",
              room: roomIdInput.value,
              payload: rtcPeerConnection.localDescription,
            })
          );
        }
      }
    </script>
  </body>
</html>
